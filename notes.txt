What operations and forms are NOT quantified?
Q represents a quantified sub-program,
(x : T), (x)
What operations are quantified over the sub-program.
{(x : T), (x)}
does this result in a quantification of collections?
What if I want to specify the quantification of a collection?
The type of a collection of a bunch of things
what about a sequence?
A, B, Q
Q, A, B
((x : T), (x)), A, B
quantify over side effects?
yes.
Q, A, B
(f (g (h ((x : T), x))))
so in this case the quantification is propagated
How would I make a sequence by quantified?
(x : T), ((A, B, x), C)



how to create operations that do not affect context?
Macros don't affect context by default.
or do i need that if i have closures?
because closures capture everything.
Also i dont want to capture too small of a tree.
how would i implement green threads?
well you'd have to call a function that captures the continuation.
So there's a list of threads, a scheduler, and a function to capture a point and switch to another thread.
What does that look like?
You can turn all of them into a yield function over a list of continuations.
(threads <- {}),
(yield <- (_ -> ))


I'd like to make an in-place insert operation.
(({1 3} \\ 1 2) = {1 2 3})

