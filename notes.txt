What operations and forms are NOT quantified?
Q represents a quantified sub-program,
(x : T), (x)
What operations are quantified over the sub-program.
{(x : T), (x)}
does this result in a quantification of collections?
What if I want to specify the quantification of a collection?
The type of a collection of a bunch of things
what about a sequence?
A, B, Q
Q, A, B
((x : T), (x)), A, B
quantify over side effects?
yes.
Q, A, B
(f (g (h ((x : T), x))))
so in this case the quantification is propagated
How would I make a sequence by quantified?
(x : T), ((A, B, x), C)



how to create operations that do not affect context?
Macros don't affect context by default.
or do i need that if i have closures?
because closures capture everything.
Also i dont want to capture too small of a tree.
how would i implement green threads?
well you'd have to call a function that captures the continuation.
So there's a list of threads, a scheduler, and a function to capture a point and switch to another thread.
What does that look like?
You can turn all of them into a yield function over a list of continuations.
(threads <- {}),
(yield <- (c -> ))


I'd like to make an in-place insert operation.
(({1 3} \\ 1 2) = {1 2 3})


What if there's an expression which accepts anything?
Does that allow quantification?
(<- ((n : {'m *}) -> (f (n \ 2))),
(m (1 + Nat))
What about quantification as iteration?
Loop incrementing an array

how to loop?
Do I do tail call optimization? yes
can I also just do continuations? yes

(countdown <- (i -> (? (i > 0) (& <- (countdown (i - 1)) i))))
(countdown <- (i -> (? (i > 0) (countdown (i - 1)) i)))
(countdown <- (i -> (& \ 0 '(? (i > 0) (& <- (i <- (i - 1))) i))))
named let is such a convenient form. 
what's the equivalent of named let?
(& <- (loop <- `(a, (& <- loop))))
is there no equivalent of named let?
No but you can make it pretty easily.
((e : {'loop Symbol Expression}) -> ((e \ 1) <- (e \ 2)), (! (e \ 1)))



lets say I want to take the context so that I can always get a value back.
Contexts are bound by functions.
New functions create new contexts.
So when I use '&, it's referring to the immediate function context.
But it's not actually, it's referring the rest of the program.
So then how would I do threads?
use a FIFO proc list.

threads <- {}

sticking point, if the function boundary is the prompt, then what happens when 
you take the context at different points?
(f <- (x -> &, (g x), &, (h x))
it all equals the lambda with fixed arguments.
How to loop
(countdown <- (n -> 
	(? (n > 0) 
	   (n ~ (n - 1)), (& <- &)
	   n)))
or does it set control to a specific point?
what about returning, can you exit to a different place?
In a sequence, the context is the position at the sequence so 
(a, (x <- &), b, c, (y <- &), d)
((x \ 0) = (b, c, d))
((y \ 0) = (d))



Say I define some function on a collection and i call it 
(f <- ((n : Collection) -> n + {0})),
(f (1 2))
how does it know to treat '(1 2) as an expression not a collection?
type tags.
(1 2) is not the same as {1 2} because there's a type tag.



how to do pointers with one symbol?
there's two operations: derive the location of some data and refer to a location
@ is pointer operations.
trivial ((@ (@ x)) = x)
that looks nice
what about taking the address of a location?
(x <- (@ y)),
((@ x) = y)
if it's possible to take the address of an address then i can do it.
I have to do some type-level wrenching to do it.
((: y) = Location), (@ (y : *))
you can't upcast.
how to get the address of an address?
there's two types of the expression, 
[({'@ *} -> Location) ({'@ Location} -> *)]
what I need is ({'@ Location} -> Location)
so what kind of type-level wrenching can do this?
if I expect a location, then thats the operation that's applied
so now I have 
(({'@ *} -> Location) : Location)
(({'@ Location} -> *) : *)
(({'@ Location} -> Location) : Location)



where to use period?
its used as a decimal point in a symbol.
1.1
what notation should it be used for?
composition?
(f : Function), (g : Function), ((f . g) : Function)
use it to terminate a bunch of closing braces.
No that's harder to read.
Actually should I use it to look up names?
dot can be used as subscript or name lookup
it's overloaded based on whether you're handing it a number or a symbol.
(m <- {(x <- 1) (y <- 2) (z <- 3)}),
((m . 1) = 1),
((m . 'x) = 1)
no this sucks


Whats my syntax?
(math <- ({Number} + ['+ '- '* '/ '//] + [{Number} math]))
(logic <- ([{Boolean} {'- Boolean}] + ['/\ '\/] + [{Boolean} {'- Boolean} logic])
(collection-algebra <- ({Collection} + ['+ '- '/] + [{Collection} collection-algebra]))
(type-algebra <- ({Type} + ['+ '- '/] + [{Type} type-algebra]))
(access <- {'. [Number Symbol access]}), {Collection} + access
{Collection '. Symbol}
{Collection '/ *}
{Collection *}
({Symbol} * Collection + {'->} + Expression)
(Function + Collection)
{'@ *}
{'@ Location}
{Number ['< '>] Number}
{Type ['< '>] Type}
{* '= *}
{'? Boolean Program Program}
{'? Boolean Program}
(data <- {'|} + [{*} {* Natural}] + [{'|} data])



What are my basic types?
- Number
  - Integer
  - Natural
- Function
- Collection
  - Type
  - Expression
  - String
- Program
  - Expression
  - Symbol
- Character
- Data
  - Value
  - Reference
  - Byte



Is it possible to statically type code when you don't know the expression?
Depends.
I can verify functions just fine and same with lambdas, so it must be the same with contexts.
Contexts are lexical boundaries with lexical closures so stuff is only bound if it's declared lexically.
There's even syntax for it, (<- *)
So let's say I enter a function and I define a lambda and an expression.
(f : (n -> 
(<- ((e : {'a *}) -> (e . 2))),
(a 1)))
You can statically type if you have prior knowledge of the meaning of the code.
In a language like mine where the meaning of a phrase is completely contextual, you don't know.
It's equivalent to introducing a new word used in the next sentence.
That's fine in English and it's proven comprehensible by AI programs.
Should be fine here too.
Should I skip lisp though and just make a different kind?
I can make more node types than just the few involved in the Lisp AST.
Multi-typed AST.
That's the way to go.
An AST node with different semantics.
I can make a new constructor for it.
Can't be at the reader level though because the primitive reader only reads certain things.
That's okay though, I don't want every possible notation.
There's a difference between being able to conveniently extend syntax and having to include every possible syntax.



So it's impossible for a function to accept any expression and apply it.
This sucks.
In Lisp, everything is a function.
Maybe I'm doing it wrong.
Pattern matching over the structure of a thing without worrying about lookup or anything.
It's highly expressive, but difficult to interpret.
A faster interpreter would be a normal Lisp where you can dispatch on the first symbol reliably.
But I want an actual language, not a functional DSL.
I want to write variable sized math expressions (1 + 2 / 4 * 5)
I want to be able to write logic expressions (True /\ - False \/ True)
There's interleaved lookup though because you can't decide for any given context that a symbol is reserved as an operator.
This means that I can absolutely do (/\ <- True), (\/ <- False), ((/\ /\ /\) = /\)
No this isn't possible because symbols are resolved before the expression is evaluated so the previous expression would be {True True True} which isn't interpretable.
If a symbol isn't bound, then it's syntax.
That's a nice simple rule.



I need a data constructor so I can create vectors and segments of data.
That's (| Value | Value | Value | Reference | Byte 100 |)



where must a blank separate two things?
(Symbol Symbol) 
(Number Number)
If two Symbols or numbers are adjacent, they must be separated by a blank.




what's a program to read in a program model?
(-> 
 (program : _),
 (symbol : ""),
 (c : character),
 (c <- (read)),
 ({
   ((n : [Glyph Digit]) -> 
     (symbol <- (symbol + {c}))
   ((n : Blank) -> 
     (? (program = _) 
        (program <- symbol), (compute program)
	(? )))
((n : "(") -> )
((n : ")") -> )
((n : "[") -> )
((n : "]") -> )
((n : "{") -> )
((n : "}") -> )
((n : "\"") -> )
((n : "'") -> )
((n : Character) -> (error))
((n : _) -> (compute program))
} c)
)