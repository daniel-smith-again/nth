There is no quantification through types since types are infinite.
Instead you have refinements via 
(T | (x -> f x))


I do not have coroutines or anything like that. 
I have CPS and macros that perform CPS transforms.


Pointers are done with only one operator.
{'@ Any} results in a reference
{'@ Reference} results in a datum
{'@ Reference} : Reference) results in a reference

Top type is "Any".
Bottom type is "None".


What are my basic types?
- Number
  - Integer
  - Natural
  - Floating (for decimal)
- Function
- Collection
  - Type
  - Expression
  - String
- Program
  - Expression
  - Symbol
- Character
- Data
  - Value
  - Reference
  - Byte


There's two kinds of types, discrete and continuous.
A discrete type is anything that has a countable number of inhabitants.
(discrete = [a b c])
A continuous type may have any number of inhabitants.
(continuous = (* | (x -> x)))

typeclass is talking about what stuff can be applied.
so if a slut is fuckable, then 
(slut = (* | (s -> (fuckable s) : *))
that's how you do a typeclass.



btw the bar represents a refinement.
(* | (x -> x))


do I handle recursive bindings?
Yes because even with recursive bindings, there's still a finite amount of constructors.
for example (a = {b}, b = {a}) where a and b are resolved before their definitions are resolved.
There's some kind of typing algorithm there.



Rule 1: New objects can only be added to the active function.
Rule 2: Objects cannot change size.
Rule 3: Objects are not discarded until their function scope exits.


How do I do macros?
Macros are just functions.
So if functions are macro objects, how do you use them?
You establish a function as a macro in the context.
Should there be an operation for that?
Yes. Macros are higher order binding.
Variables result in value substitution.
Macros result in program substitution.


What's my macro use-case?
I import the Calculus image.
It defines macros for integration and derivation as syntax transforms.
I can then use those macros in the scope where I imported the image.

I can also import the M-Notation image and the N-Impl image and they combine to form macros with M-style syntax and N-style rewrites.
How does that even work though? 
It doesn't. 
I'm expressing something else.



The "unit" is an image. It has a uniform interface whether it's compiled or not.
You combine images and use them using linker commands.