There is no quantification through types since types are infinite.
Instead you have refinements via 
(T | (x -> f x))
The bar is a higher order function that constructs a type as a relation between an existing type and a predicate as a function.



I do not have coroutines or anything like that. 
I have CPS and macros that perform CPS transforms.
If you want actual parallelism, you need to communicate with the operating system.


Pointers are done with only one operator.
{'@ Any} results in a reference
{'@ Reference} results in a datum
{'@ Reference} : Reference) results in a reference

Top type is "Any".
Bottom type is "None".


What are my basic types?
- Number
  - Integer
  - Natural
  - Floating (for decimal)
- Function
- Collection
  - Type
  - Expression
  - String
- Program
  - Expression
  - Symbol
- Character
- Data
  - Value
  - Reference
  - Byte


There's two kinds of types, discrete and continuous.
A discrete type is anything that has a countable number of inhabitants.
(discrete = [a b c])
A continuous type may have any number of inhabitants.
(continuous = (* | (x -> x)))

typeclass is talking about what stuff can be applied.
so if a slut is fuckable, then 
(slut = (* | (s -> (fuckable s) : *))
that's how you do a typeclass.



btw the bar represents a refinement.
(* | (x -> x))


do I handle recursive bindings?
Yes because even with recursive bindings, there's still a finite amount of constructors.
for example (a = {b}, b = {a}) where a and b are resolved before their definitions are resolved.
There's some kind of typing algorithm there.



Rule 1: New objects can only be added to the active function.
Rule 2: Objects cannot change size.
Rule 3: Objects are not discarded until their function scope exits.



I can also import the M-Notation image and the N-Impl image and they combine to form macros with M-style syntax and N-style rewrites.
How does that even work though? 
It doesn't. 
I'm expressing something else.



The "unit" is an image. It has a uniform interface whether it's compiled or not.
You combine images and use them using linker commands.
You can get symbols, import objects, and other stuff.




What are my typing rules for a Collection?
Constructor...			{ ... }
	A collection has a zero or more elements.
	A collection with zero elements has a cardinality of zero.
	All collections with cardinalities of zero are equal.
	Each element has an index corresponding to the cardinality of the collection without the element plus one.
	The cardinality of a collection is equal to the index of the last element.
	The type of a collection is equal to the collection of types such that the element at the same index is a member of that type.

Union...			{} + {}
	Union constructs a new collection by adding the elements of the right to the left.
	The indicies of the elements being added must be at least one greater than the cardinality of the left Collection.
	The cardinality of the resulting collection is equivalent to the sum of the cardinalities of the left and right collections.
	The resulting collection must exhibit all the properties of a collection having resulted from a collection constructor.

Difference...			{} - {}
	Difference constructs a collection by removing elements from the left collection which are also elements of the right collection.
	The indicies of elements in the resulting collection must be sequential by one, and no greater than the cardinality.
	Given any pair of elements in the left collection, if both elements are in the resulting collection, the element with the greater index in the left collection must have a greater index in the resulting collection.
	The cardinality of the resulting collection must be equivalent to the cardinality of the right collection subtracted from the left.

Membership...			{} / Any
	Membership will yield an element of the left collection which is equivalent to the value on the right.
	If the value on the right is a type, then Membership will yield a collection of all elements which are also elements of that type.
	If the collection on the left has no elements which are equal or members of the value on the right, then Nil is returned.

Subscript...			{} _ Natural
	Subscript will yield an element with an index equivalent to the natural number given on the right.
	If the number given on the right is greater than the cardinality of the collection, Nil is returned.
	If the number given on the right is zero, the outer collection is given, or else the left collection is given.

Product...			{} * [Natural Collection]
	Product will yield a collection with the elements of the collection on the left repeating as many times as the value on the right.
	The number of repetitions is taken either as the natural number or the cardinality of the collection on the right.
	The resulting collection must exhibit all properties of a collection resulting from a constructor.



How do I do quotes?
Single apostrophe is quote which treats an expression as data.
It's also the expression constructor.
Within a single apostrophe, if a double apostrophe occurs (''), that means to evaluate the sub-form and insert the result.
Within a single apostrophy, if a triple apostrophe occurs ('''), that means to evaluate the sub-form and expand the result so each atom appears in sequence in the quoted form.
'(1 2 3) == {1 2 3}
(let (x 1) in '(''x 2 3)) == {1 2 3}
(let (x {2 3}) in '(1 '''x)) == {1 2 3}
Stacking quotations still works, just separate them with whitespace.



What is the special binding '&?
It is a virtual structure which refers to the active function and its context.
It is a collection which represents all data in a function.
It contains a circular reference to the function, so you can call it with fresh parameters.
Recursion is then (x -> (& x))
What index is the function?
The first or the last?
The last.
The first index is the first parameter, so you can do
(x -> (& _ 1)) which is equivalent to (x -> x)


What are bindings?
They're functions of (Symbol -> *)
Bindings are resolved during application.
Application will either thunk expression parameters or lookup symbol parameters.


What can I expression from independent constraint variables?
I can say that a function must yeild the same object.

(n : T, f : ((n) -> n))
What else can it do?
it can yield a type as in, (n : T, (g n)) where the type of the result of (g n) 
is yielded.



native support for computed goto?

(do (switch :: {(_ -> 'a) (_ -> 'b) (_ -> 'c)})
(switch (f x))


finally figured out macros.
You bind a macro to a symbol.
(m :: ((Expression) -> *))
Then you can put the symbol anywhere in a form.
(1 + m - 3)
When it appears in a form, the macro definition is applied to the form.
Multiple macros can be used in a single form.
They're dispatched in order of occurrence.
What about arbitrary overloading?
That works the same way as normal binding.
You can overload any binding by constraining an orthogonal type.
('+ : ('(A + B) -> (& _ 1)))

if I have a constraint, (x : T), I can refine the constraint (x : (t : T)), 
or I can add an orthogonal constraint, (x : K), which is the same as,
(x : [T K]).



What is the name for the function that constructs a collection?
Construct
What is the name for the function that constructs a type?
Take
What is the name for the function that constructs a function?
Abstract
What is the name for the function that constructs a binding?
Let

verbs as in "Construct a Collection", "Take a Type", "Abstract a Function", and "Let a Binding".

(Let x (Elements A B (Members T t)))

Can you actually do variadic functions during runtime?
No, use a collection instead.
The reason the primitives work is because they're primitives with special behavior.



prove leftpad...
leftpad is a function that takes a character, a number, and a string, and 
prepends the character, as many times as the number, to the beginning of the string.

(leftpad = ((c : Character) (n : Natural) (s : String) -> 
           ((({c} * n) + s) : (String | (k -> ((# k) = ((# s) + n)))))
Or prove it this way

(leftpad : (do (c : Character) (n : Natural) (s : String) (c n s -> (({c} * n) + s)))
(leftpad = ((c : Character) (n : Natural) (s : String) -> ((({c} * n) + s) : String)))



I really want to use equality for stuff, but it makes macros hard since you 
can't tell what exactly the equality expression is gonna do.
There's a special case where a single symbol is unbound on the lhs, rhs, or both
(x = 1) (1 = x) (x = y)
It does not support expressions like ((x + 1) = 2) because this requires an 
inverse.
If an unbound symbol appears on either side, it's the same as (let _ ...) 
for that symbol.



How are macros different than other functions?
They accept a program type which is only available before a program is run.
How do you do something like that?
You use (let x)
where x is a macro function.
stuff : [
	((e : {'a *}) -> (e _ 2))
	((e : {'b *}) -> (e _ 2))
]
(let stuff)
This is enough.
If you want a package, do 
(let ((import k) . stuff))
everything is a macrolet.
(k = (import "k"))
(let (k . syntax))
So the mechanism is that you (let f) where f is a function that's used to 
transform expressions.



how do I do refinements?
My notation right now is to associate a function with some type.
(T | (x -> (? (P x) True False)))
This is the same as 
(do (x : T) (? (P x) x))
(P (x : T)) 
these all produce type refinements.
So what would a vector constructor look like?
(vec : (d m -> ))

Instead of (x : y) where x is one of y, 
(x :: y) where x satisfies y.




So when I want to talk about the dependent result of a function, I do
((c : Character) (n : Natural) (s : String) -> (({c} * n) + s))

