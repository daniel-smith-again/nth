You should only ever be five lines away from networks, peripherals, and concurrency.

In Haskell...
  class TypeOf a where
    typeOf :: a -> String
  instance TypeOf Bool where
    typeOf _ = "Bool"
  instance TypeOf Char where
    typeOf _ = "Char"
  instance (TypeOf a, TypeOf b) => TypeOf (a, b) where
    typeOf(a, b) = "(" ++ typeOf a ++ "' " ++ typeOf b ++ ")"
|> typeOf (True, 'a')
   "(Bool, Char)"

In nth...
  (define TypeOf (-> String))
  (define (typeOf : TypeOf) 
    (type
      ((Boolean) -> "Boolean")
      ((Character) -> "Character")
      (a b -> "\(typeOf a), \(typeOf b)")))
|> (typeOf True "a")
   "(Boolean, Character)"

I only support Integers.
Integers are shared by everything.
You can accomplish most stuff with just integers.
If you want more, just add additional stuff on top of integers.
Plus I have ranges which are static sized integers.



(quicksort = ((list : Array) -> 
 ? ((# list) > 1) 
   (swap = (pv i j ->
    ??
      (((list _ i) < (list _ pv)) and (i < pv))
      (swap pv (i + 1) j)
      (((list _ j) > (list _ pv)) and (j > pv))
      (swap pv i (j - 1))
      (((list _ j) < (list _ pv)) and ((list _ i) < (list _ pv)))
      (tmp = (list _ i),
       list _ i (list _ j),
       list _ j tmp,
       swap pv i j),
      (quicksort ((@ (@ (list _ 1))) : (Collection | 
                 (c -> (? ((# c) = ((# list) - pv)) True))))),
      (quicksort ((@ (@ (list _ (pivot _ 1)))) : (Collection | 
                 (c -> (? ((# c) = ((# list) - pv)) True)))))))))





"This is the first line.
This is the second line"

"This is the first line.\(Newline)
This is the second line."

"This is the first line." + Newline +
"This is the second line."


When I want to include code from a separate module, there's three ways.

Compile the code as part of the artiface.
Allow the code to be linked by the system linker.
Link to the code during runtime.

"Static",
(define ABC (! 'libABC)),
(define foo (ABC . foo)),
(foo "data")

"Linking",
(define ABC (! 'libABC)),
((ABC . foo) "data")

"Load Time",
(let ABC = (! 'libABC)
 in  (ABC . foo) "data")


is (array Symbol 100)
a supertype of
(collection 'Symbol)?

can inversion be a macro?
maybe?
if it's static it can.

({ a b c d })
( a ; b ; c ; d ; e)
(collection a b c d e)
(# a b c d e)


big big big question
--------------------------------------------------------------------------------
how does the compiler enforce this type?
(define evens (Number | (n -> (n mod 2) = 0)))
Can it even verify this?
Say I have (x : evens)
If I do (x = (5 * 324 + 7)), how does the compiler verify that this expression 
conforms to the type?
I can't enforce it.

The point of having types like this was to be able to talk about what a
program does. This doesn't do it.

All I really need is an assertion macro. This doesn't appropriately constrain
the language in any useful way. It would be much better to use 
inversion consumers and producers. Inversion is not just control flow, but 
also a way to guarantee behavior.

So what if I want to write an expression which matches >>
('('''(type Symbol Collection) >> ''Program) -> *)

================================================================================

What problem am I solving with my language?
ALGOL style languages suck and other languages which suck less aren't 
ergonomic for targetting the same things as the sucky languages.
They suck because...

* The feedback cycle isn't instantaneous
* Every language assumes no other exists
* Constructs are inefficient for humans and computers too
* You can't perform basic program validation in the language

* Live, Session based programming
  You should be able to ask high level questions about your program.

* Extractable
  You should be able to take the program you built, and export it to some 
  binary machine-interpreted format in a generic way.

* It's up, all the way down
  The language is the bottom, top, and every abstraction in-between.

* Extensible abstractions
  There's a feature you want, go ahead and code it.

* Predictable Automatic Memory Management
  Everything belongs to some function scope and exists as long as that scope

* Types and Polymorphism
  The compiler doesn't have to guess about the shape of data.