There is no quantification through types since types are infinite.
Instead you have refinements via 
(T | (x -> f x))
The bar is a higher order function that constructs a type as a relation between an existing type and a predicate as a function.



I do not have coroutines or anything like that. 
I have CPS and macros that perform CPS transforms.
If you want actual parallelism, you need to communicate with the operating system.


Pointers are done with only one operator.
{'@ Any} results in a reference
{'@ Reference} results in a datum
{'@ Reference} : Reference) results in a reference

Top type is "Any".
Bottom type is "None".


What are my basic types?
- Number
  - Integer
  - Natural
  - Floating (for decimal)
- Function
- Collection
  - Type
  - Expression
  - String
- Program
  - Expression
  - Symbol
- Character
- Data
  - Value
  - Reference
  - Byte


There's two kinds of types, discrete and continuous.
A discrete type is anything that has a countable number of inhabitants.
(discrete = [a b c])
A continuous type may have any number of inhabitants.
(continuous = (* | (x -> x)))

typeclass is talking about what stuff can be applied.
so if a slut is fuckable, then 
(slut = (* | (s -> (fuckable s) : *))
that's how you do a typeclass.



btw the bar represents a refinement.
(* | (x -> x))


do I handle recursive bindings?
Yes because even with recursive bindings, there's still a finite amount of constructors.
for example (a = {b}, b = {a}) where a and b are resolved before their definitions are resolved.
There's some kind of typing algorithm there.



Rule 1: New objects can only be added to the active function.
Rule 2: Objects cannot change size.
Rule 3: Objects are not discarded until their function scope exits.



I can also import the M-Notation image and the N-Impl image and they combine to form macros with M-style syntax and N-style rewrites.
How does that even work though? 
It doesn't. 
I'm expressing something else.



The "unit" is an image. It has a uniform interface whether it's compiled or not.
You combine images and use them using linker commands.
You can get symbols, import objects, and other stuff.




What are my typing rules for a Collection?
Constructor...			{ ... }
	A collection has a zero or more elements.
	A collection with zero elements has a cardinality of zero.
	All collections with cardinalities of zero are equal.
	Each element has an index corresponding to the cardinality of the collection without the element plus one.
	The cardinality of a collection is equal to the index of the last element.
	The type of a collection is equal to the collection of types such that the element at the same index is a member of that type.

Union...			{} + {}
	Union constructs a new collection by adding the elements of the right to the left.
	The indicies of the elements being added must be at least one greater than the cardinality of the left Collection.
	The cardinality of the resulting collection is equivalent to the sum of the cardinalities of the left and right collections.
	The resulting collection must exhibit all the properties of a collection having resulted from a collection constructor.

Difference...			{} - {}
	Difference constructs a collection by removing elements from the left collection which are also elements of the right collection.
	The indicies of elements in the resulting collection must be sequential by one, and no greater than the cardinality.
	Given any pair of elements in the left collection, if both elements are in the resulting collection, the element with the greater index in the left collection must have a greater index in the resulting collection.
	The cardinality of the resulting collection must be equivalent to the cardinality of the right collection subtracted from the left.

Membership...			{} / Any
	Membership will yield an element of the left collection which is equivalent to the value on the right.
	If the value on the right is a type, then Membership will yield a collection of all elements which are also elements of that type.
	If the collection on the left has no elements which are equal or members of the value on the right, then Nil is returned.

Subscript...			{} _ Natural
	Subscript will yield an element with an index equivalent to the natural number given on the right.
	If the number given on the right is greater than the cardinality of the collection, Nil is returned.
	If the number given on the right is zero, the outer collection is given, or else the left collection is given.

Product...			{} * [Natural Collection]
	Product will yield a collection with the elements of the collection on the left repeating as many times as the value on the right.
	The number of repetitions is taken either as the natural number or the cardinality of the collection on the right.
	The resulting collection must exhibit all properties of a collection resulting from a constructor.



How do I do quotes?
Single apostrophe is quote which treats an expression as data.
It's also the expression constructor.
Within a single apostrophe, if a double apostrophe occurs (''), that means to evaluate the sub-form and insert the result.
Within a single apostrophy, if a triple apostrophe occurs ('''), that means to evaluate the sub-form and expand the result so each atom appears in sequence in the quoted form.
'(1 2 3) == {1 2 3}
(let (x 1) in '(''x 2 3)) == {1 2 3}
(let (x {2 3}) in '(1 '''x)) == {1 2 3}
Stacking quotations still works, just separate them with whitespace.



What is the special binding '&?
It is a virtual structure which refers to the active function and its context.
It is a collection which represents all data in a function.
It contains a circular reference to the function, so you can call it with fresh parameters.
Recursion is then (x -> (& x))
What index is the function?
The first or the last?
The last.
The first index is the first parameter, so you can do
(x -> (& _ 1)) which is equivalent to (x -> x)


What are bindings?
They're functions of (Symbol -> *)
Bindings are resolved during application.
Application will either thunk expression parameters or lookup symbol parameters.


What can I expression from independent constraint variables?
I can say that a function must yeild the same object.

(n : T, f : ((n) -> n))
What else can it do?
it can yield a type as in, (n : T, (g n)) where the type of the result of (g n) 
is yielded.



native support for computed goto?

(do (switch :: {(_ -> 'a) (_ -> 'b) (_ -> 'c)})
(switch (f x))


finally figured out macros.
You bind a macro to a symbol.
(m :: ((Expression) -> *))
Then you can put the symbol anywhere in a form.
(1 + m - 3)
When it appears in a form, the macro definition is applied to the form.
Multiple macros can be used in a single form.
They're dispatched in order of occurrence.
What about arbitrary overloading?
That works the same way as normal binding.
You can overload any binding by constraining an orthogonal type.
('+ : ('(A + B) -> (& _ 1)))

if I have a constraint, (x : T), I can refine the constraint (x : (t : T)), 
or I can add an orthogonal constraint, (x : K), which is the same as,
(x : [T K]).



What is the name for the function that constructs a collection?
Construct
What is the name for the function that constructs a type?
Take
What is the name for the function that constructs a function?
Abstract
What is the name for the function that constructs a binding?
Let

verbs as in "Construct a Collection", "Take a Type", "Abstract a Function", and "Let a Binding".

(Let x (Elements A B (Members T t)))

Can you actually do variadic functions during runtime?
No, use a collection instead.
The reason the primitives work is because they're primitives with special behavior.



prove leftpad...
leftpad is a function that takes a character, a number, and a string, and 
prepends the character, as many times as the number, to the beginning of the string.

(leftpad = ((c : Character) (n : Natural) (s : String) -> 
           ((({c} * n) + s) : (String | (k -> ((# k) = ((# s) + n)))))
Or prove it this way

(leftpad : (do (c : Character) (n : Natural) (s : String) (c n s -> (({c} * n) + s)))
(leftpad = ((c : Character) (n : Natural) (s : String) -> ((({c} * n) + s) : String)))



I really want to use equality for stuff, but it makes macros hard since you 
can't tell what exactly the equality expression is gonna do.
There's a special case where a single symbol is unbound on the lhs, rhs, or both
(x = 1) (1 = x) (x = y)
It does not support expressions like ((x + 1) = 2) because this requires an 
inverse.
If an unbound symbol appears on either side, it's the same as (let _ ...) 
for that symbol.



How are macros different than other functions?
They accept a program type which is only available before a program is run.
How do you do something like that?
You use (let x)
where x is a macro function.
stuff : [
	((e : {'a *}) -> (e _ 2))
	((e : {'b *}) -> (e _ 2))
]
(let stuff)
This is enough.
If you want a package, do 
(let ((import k) . stuff))
everything is a macrolet.
(k = (import "k"))
(let (k . syntax))
So the mechanism is that you (let f) where f is a function that's used to 
transform expressions.



how do I do refinements?
My notation right now is to associate a function with some type.
(T | (x -> (? (P x) True False)))
This is the same as 
(do (x : T) (? (P x) x))
(P (x : T)) 
these all produce type refinements.
So what would a vector constructor look like?
(vec : (d m -> ))

Instead of (x : y) where x is one of y, 
(x :: y) where x satisfies y.




So when I want to talk about the dependent result of a function, I do
((c : Character) (n : Natural) (s : String) -> (({c} * n) + s))



what's my rules for Rewrite, Resolve, and Reduce?


(do 
(let ({'a *} -> (& _ 1 _ 2)))
(a 1))

Rewrite, Resolve, and Reduce are three states of a Program Model.
At each stage, data is moved from the program model to the context.
The context is a store of bindings and information which is necessary to complete execution.

So how do I resolve macros?
They have to be bound before you do anything.
(do (let ({'a T} -> (& _ 1 _ 2))))
The context can be accessed by the ampersand.
The ampersand accepts function application in which it will apply the active function.
The ampersand can be subscripted to access parameters and data bound in a context.
The ampersand supports field lookup.

Function context needs 
	- the function object
	- the function parameters
	- the bindings



How do I talk about collections?
I can say a collection has 
	"cardinality of n"
	"includes x"
	"excludes x"
	"repeats x"
	"x at index y"
Additionally, I want to talk about vectors which are collections where each index has the same type.
A vector has 
	"cardinality of n"
	"repeats x"

How do I do symbol macros?
Talk about a symbol as a string.
A symbol is a string.
If I quote a symbol I get 
'symbol

(x .. n)
(x ..)
(.. n)
Sequence
(x ..)
(.. n)
(x .. n)

Collection > Sequence > (* ..) > (.. *) > (* .. *)

What's a vector, a collection where every index is the same type.
They are a form of collection, but with a strict distinction.
{* '..} 
{'.. Natural}
{* '.. Natural}
What is a collection of a length?
(* : Collection)



(x : T, abc)



What's a good example of syntax? McCarthy 91 Function.
What about Quicksort?

(quicksort = ((list : Vector) -> 
 ? ((# list) > 1) 
   (swap = (pv i j ->
    ??
      (((list _ i) < (list _ pv)) and (i < pv))
      (swap pv (i + 1) j)
      (((list _ j) > (list _ pv)) and (j > pv))
      (swap pv i (j - 1))
      (((list _ j) < (list _ pv)) and ((list _ i) < (list _ pv)))
      (tmp = (list _ i),
       list _ i (list _ j),
       list _ j tmp,
       swap pv i j),
      (quicksort ((@ (@ (list _ 1))) : (Collection | 
                 (c -> (? ((# c) = ((# list) - pv)) True))))),
      (quicksort ((@ (@ (list _ (pivot _ 1)))) : (Collection | 
                 (c -> (? ((# c) = ((# list) - pv)) True)))))))))
cool, this isn't many more lines than C/C++



How do I talk about collections?
A collection can 
- Contain a thing
- Have a length
- Be a vector
The deal is you can't actually create a collection with incomplete information.
Which means if you want to create a vector you do.
({A} * 100)
What if you want to talk about abstract length?
({*} * 100)
What if you want to talk about contains?
That one's tricky.
((* : Collection) + {x})
Any collection that contains x

Can you use types as blanks?
Yes.
If a hole accepts a member of a type, then providing the type quantifies that 
expression.
This is pathological as the result of quantified nested expression will force
quantification of the outer expression.
When does a quantified expression stop?
When the outer expression accepts anything.





Default functions...
Quote : ((Expression) -> Program)
Evaluate : ((Program) -> Data)
Create : ((fields : Collection) -> Collection)
Take : ((members : Collection) -> Type)
Abstract : ((parameters : ({Symbol} * Number)) Expression -> Function)
Let : ((x : Symbol) y -> y)
Let : (Function -> Nil)
Sum : (({Number} *) -> Number)
Sum : ((Collection ...) -> Collection)
Dif : (({Number} *) -> Number)
Dif : (({Collection} *) -> Collection)
Dif : ((Collection) Any -> Collection)
Mul : (({Number} * Number) -> )

? : (({Boolean Program} *) -> [Any Nil]) 
? : ((({Boolean Program} *) + {Program}) -> Any)


Can I do boolean case matching?
(? cond succ)
(? cond succ fail)
(? cond succ cond succ)
(? cond succ cond succ fail)



How do I express a collection that contains?
	(Collection | (c -> (? (C / T) C)))

I have effect handlers using the higher order function, (with ... _)
(with) takes a number of symbol function pairs.
(with 
f (x -> x) 
g (x -> x) 
(f g 1)
)
with will either return the result of the last expression, or the result of
one of the handlers.
The handler will either resume back to the last expression, or return a value
out of the with.
The first parameter is the resumption.

(with ... _)
binds effect handlers to symbols which may be used within the last expression.

lexical shit is not portable.
The more I tie stuff to a lexical domain, the more I can't reuse any of it.
the (with ... _) form does not allow for re-useable effects right now.
I can change this by letting (with x) propagate the binding.
so if I supply (with (x)), then it simply passes the function through as `x`.

how do i do a higher order binding?
you assign an expression to a thing.
so naming a binding exposes it in scope?

(do 
   (x = 1)
   (= ({'a 'b} -> '(x + 1)))
   (a b))

(do 
   (g : Function)
   (f = (x -> g x))
   (g = (x -> f x))
   (f x))

Comparisons are part of conditional expressions.
There aren't comparisons outside of conditional expressions since their use is so rare.

there is no let. I don't need let if I have binding.

(Success = [* True])
(Failure = [_ False])
(Judgement = [Success Failure])
(({'? Judgement} + ({Expression} *)) -> *)
({Symbol '= *} -> (& _ 1 _ 3))
({* '= *} -> Judgement)

I want images to be a first class data type.
An image is an object which enforces encapsulation.
Multiple images can be live within a program.
An image has its own internal state.
Because of encapsulation, you have to be standing in the image to change it.
Images are built up sequentially.
An image of types is a supertype of an image of inhabitants.


so what about macros?
There should be specific spots where macros are permitted.
using let.
actually that sucks, just provide syntax to the image.
so how does that work?
(syntax ({'a 'b} -> 'c))

(use 'image)