What operations and forms are NOT quantified?
Q represents a quantified sub-program,
(x : T), (x)
What operations are quantified over the sub-program.
{(x : T), (x)}
does this result in a quantification of collections?
What if I want to specify the quantification of a collection?
The type of a collection of a bunch of things
what about a sequence?
A, B, Q
Q, A, B
((x : T), (x)), A, B
quantify over side effects?
yes.
Q, A, B
(f (g (h ((x : T), x))))
so in this case the quantification is propagated
How would I make a sequence by quantified?
(x : T), ((A, B, x), C)



how to create operations that do not affect context?
Macros don't affect context by default.
or do i need that if i have closures?
because closures capture everything.
Also i dont want to capture too small of a tree.
how would i implement green threads?
well you'd have to call a function that captures the continuation.
So there's a list of threads, a scheduler, and a function to capture a point and switch to another thread.
What does that look like?
You can turn all of them into a yield function over a list of continuations.
(threads <- {}),
(yield <- (c -> ))


I'd like to make an in-place insert operation.
(({1 3} \\ 1 2) = {1 2 3})


What if there's an expression which accepts anything?
Does that allow quantification?
(<- ((n : {'m *}) -> (f (n \ 2))),
(m (1 + Nat))
What about quantification as iteration?
Loop incrementing an array

how to loop?
Do I do tail call optimization? yes
can I also just do continuations? yes

(countdown <- (i -> (? (i > 0) (& <- (countdown (i - 1)) i))))
(countdown <- (i -> (? (i > 0) (countdown (i - 1)) i)))
(countdown <- (i -> (& \ 0 '(? (i > 0) (& <- (i <- (i - 1))) i))))
named let is such a convenient form. 
what's the equivalent of named let?
(& <- (loop <- `(a, (& <- loop))))
is there no equivalent of named let?
No but you can make it pretty easily.
((e : {'loop Symbol Expression}) -> ((e \ 1) <- (e \ 2)), (! (e \ 1)))



lets say I want to take the context so that I can always get a value back.
Contexts are bound by functions.
New functions create new contexts.
So when I use '&, it's referring to the immediate function context.
But it's not actually, it's referring the rest of the program.
So then how would I do threads?
use a FIFO proc list.

threads <- {}

sticking point, if the function boundary is the prompt, then what happens when 
you take the context at different points?
(f <- (x -> &, (g x), &, (h x))
it all equals the lambda with fixed arguments.
How to loop
(countdown <- (n -> 
	(? (n > 0) 
	   (n ~ (n - 1)), (& <- &)
	   n)))
or does it set control to a specific point?
what about returning, can you exit to a different place?
In a sequence, the context is the position at the sequence so 
(a, (x <- &), b, c, (y <- &), d)
((x \ 0) = (b, c, d))
((y \ 0) = (d))



Say I define some function on a collection and i call it 
(f <- ((n : Collection) -> n + {0})),
(f (1 2))
how does it know to treat '(1 2) as an expression not a collection?
type tags.
(1 2) is not the same as {1 2} because there's a type tag.



how to do pointers with one symbol?
there's two operations: derive the location of some data and refer to a location
@ is pointer operations.
trivial ((@ (@ x)) = x)
that looks nice
what about taking the address of a location?
(x <- (@ y)),
((@ x) = y)
if it's possible to take the address of an address then i can do it.
I have to do some type-level wrenching to do it.
((: y) = Location), (@ (y : *))
you can't upcast.
how to get the address of an address?
there's two types of the expression, 
[({'@ *} -> Location) ({'@ Location} -> *)]
what I need is ({'@ Location} -> Location)
so what kind of type-level wrenching can do this?
if I expect a location, then thats the operation that's applied
so now I have 
(({'@ *} -> Location) : Location)
(({'@ Location} -> *) : *)
(({'@ Location} -> Location) : Location)



where to use period?
its used as a decimal point in a symbol.
1.1
what notation should it be used for?
composition?
(f : Function), (g : Function), ((f . g) : Function)
use it to terminate a bunch of closing braces.
No that's harder to read.
Actually should I use it to look up names?
dot can be used as subscript or name lookup
it's overloaded based on whether you're handing it a number or a symbol.
(m <- {(x <- 1) (y <- 2) (z <- 3)}),
((m . 1) = 1),
((m . 'x) = 1)
no this sucks


Whats my syntax?
(math <- ({Number} + ['+ '- '* '/ '//] + [{Number} math]))
(logic <- ([{Boolean} {'- Boolean}] + ['/\ '\/] + [{Boolean} {'- Boolean} logic])
(collection-algebra <- ({Collection} + ['+ '- '/] + [{Collection} collection-algebra]))
(type-algebra <- ({Type} + ['+ '- '/] + [{Type} type-algebra]))
(access <- {'. [Number Symbol access]}), {Collection} + access
{Collection '. Symbol}
{Collection '/ *}
{Collection *}
({Symbol} * Collection + {'->} + Expression)
(Function + Collection)
{'@ *}
{'@ Location}
{Number ['< '>] Number}
{Type ['< '>] Type}
{* '= *}
{'? Boolean Program Program}
{'? Boolean Program}
(data <- {'|} + [{*} {* Natural}] + [{'|} data])



What are my basic types?
- Number
  - Integer
  - Natural
- Function
- Collection
  - Type
  - Expression
  - String
- Program
  - Expression
  - Symbol
- Character
- Data
  - Value
  - Reference
  - Byte



Is it possible to statically type code when you don't know the expression?
Depends.
I can verify functions just fine and same with lambdas, so it must be the same with contexts.
Contexts are lexical boundaries with lexical closures so stuff is only bound if it's declared lexically.
There's even syntax for it, (<- *)
So let's say I enter a function and I define a lambda and an expression.
(f : (n -> 
(<- ((e : {'a *}) -> (e . 2))),
(a 1)))
You can statically type if you have prior knowledge of the meaning of the code.
In a language like mine where the meaning of a phrase is completely contextual, you don't know.
It's equivalent to introducing a new word used in the next sentence.
That's fine in English and it's proven comprehensible by AI programs.
Should be fine here too.
Should I skip lisp though and just make a different kind?
I can make more node types than just the few involved in the Lisp AST.
Multi-typed AST.
That's the way to go.
An AST node with different semantics.
I can make a new constructor for it.
Can't be at the reader level though because the primitive reader only reads certain things.
That's okay though, I don't want every possible notation.
There's a difference between being able to conveniently extend syntax and having to include every possible syntax.



So it's impossible for a function to accept any expression and apply it.
This sucks.
In Lisp, everything is a function.
Maybe I'm doing it wrong.
Pattern matching over the structure of a thing without worrying about lookup or anything.
It's highly expressive, but difficult to interpret.
A faster interpreter would be a normal Lisp where you can dispatch on the first symbol reliably.
But I want an actual language, not a functional DSL.
I want to write variable sized math expressions (1 + 2 / 4 * 5)
I want to be able to write logic expressions (True /\ - False \/ True)
There's interleaved lookup though because you can't decide for any given context that a symbol is reserved as an operator.
This means that I can absolutely do (/\ <- True), (\/ <- False), ((/\ /\ /\) = /\)
No this isn't possible because symbols are resolved before the expression is evaluated so the previous expression would be {True True True} which isn't interpretable.
If a symbol isn't bound, then it's syntax.
That's a nice simple rule.



I need a data constructor so I can create vectors and segments of data.
That's (| Value | Value | Value | Reference | Byte 100 |)



where must a blank separate two things?
(Symbol Symbol) 
(Number Number)
If two Symbols or numbers are adjacent, they must be separated by a blank.




what's a program to read in a program model?
(-> 
 (program : _),
 (symbol : ""),
 (c : character),
 (c <- (read)),
 ({
   ((n : [Glyph Digit]) -> 
     (symbol <- (symbol + {c}))
   ((n : Blank) -> 
     (? (program = _) 
        (program <- symbol), (compute program)
	(? )))
((n : "(") -> )
((n : ")") -> )
((n : "[") -> )
((n : "]") -> )
((n : "{") -> )
((n : "}") -> )
((n : "\"") -> )
((n : "'") -> )
((n : Character) -> (error))
((n : _) -> (compute program))
} c)
)


how bad is it if I don't have complicated multiple operation forms?

What would be the type if I can't

(1 + (2 + ((3 - 1) / 1.5)))

Add together three collections
(Collection + (Collection + Collection))

logic problems
((True \/ True) /\ (False \/ True)) 
vs 
(True \/ True /\ False \/ True)



How do I talk about arrays?
I need a language for storage where I talk about how things are arranged spatially in the environment.
A Data language.
I can have a adjacent pair, or a vector.
This is different than a collection which is based on access and types.
Data has no type.
There's simple data and compound data.
Data is how you represent and organize information.
You have a single unit, a large unit, an a reference unit.
Call these 
Unit
Block
Reference

A Unit is the smallest single amount of data that can be stored.
A Block is the amount of data that can be operated on. It implies multiple 
A Reference is a unique abstract value corresponding to the location of a unit.
A Pair is to adjacent Data.
A Vector is a number of adjacent data.

Do I want the rest of the abstractions then? Yes.
It's nice that I have a language to talk about how things are represented, but
there's abstract concepts which should not be bound by format and storage requirements.
Or should they?
Yes.
The format of abstractions should be implementation dependent, but they should be extensible.
Or should I start from nothing with no type system?
That's dumb. I want a bunch of stuff built in.
There will always be some concept of digital storage.
My language is designed to be run on a computer rather than some abstract symbolic machine.
It's true that the symbolic part isn't even required.
But then how do you talk to the machine?



I don't like my language anymore.
There's a weird uncanny valley between the higher level abstractions and the lower level ones.
This should be fine though because I have functions to pass between each.
Also the point is that there is a sub-language to talk about how things are stored which is separate from the semantics of computation.
Just how there's a sub-language to talk about how numbers are worked.
This is actually suitable because you can make Unit, Block, and Reference be anything you need.



weirdness with the program model.
(1 + 1) ==> {1 '+ 1}
(({'a 'b} + {'c}) / 'b) ==> {{{'a 'b} '+ {'c}} / 'b}
Collections are part of the program model, but they're nominally typed as expressions.


How do I make undecideable syntax?
Easily.
(f : ((A) -> B)),
(f : ((A) -> C)),
(g : ((B) -> A)),
(g : ((C) -> A)),
(g (f A))
This is quantification though.
Do I need quantification? Yes.



Should I have two different languages for structuring data?
Yes because one kind of structure is about access an indirection, the other kind
is about relative position.
When I talk about data, I have a Unit, a Reference, and a Block.
A Block is some combination of Units and References.
Unit, Value, Register, Block.
A Block is made up of Units, Values, and Registers.
It is either a pair of adjacent data, or a vector of a single type of data.
(Unit | 100)
(Character : (Unit | 4))
(Character : Value)



Does a sequence form its own context? 
In other words, are the effects of the discarded expressions discarded as well as their results?
No. A sequence only means "this then finally that".
All of it occurs within the same context.
If you want to discard a context, then use a function,
((_ -> A, B, C)) 
that is a "code block"



What about effects?
I have a function, it does (f : (x -> x))
It doesn't affect anything, it just produces a value.
What about 
	(y <- 1), (f : (x -> (y <- x)))
that has an effect.
What about (f : (x -> (display x)))
that has an effect too.
I can't do effects because my language isn't abstracted from the effectful system.



Interfaces, Traits, and Typeclasses are ways to reason about the capabilities of a given abstraction.
"InTraClass" describes the idea of describing the capabilities of a type as the functions over it.
Take a type T, and an InTraClass M.
If M exposes the function f : M -> M, then 
f : T -> T means that T < M.
Normally InTraClasses are ad-hoc in that the implementations of the exposed 
capabilities can be defined at any point before the instantiation of the Intraclass is used.
Normal classes are not ad-hoc and the complete class definition must be given in a single declaration.
Interfaces and traits do not require this and only differ in classification of sub-type relations and inheritance.
I do not have interfaces because abstractions are not typed by the functions defined over them.

If I did want to make an Intraclass exposing a capability, I would have to write something like
Say I make some Intraclass "hash-able" with a capability "hash".
How would I make that for two types T and t such that both can be sub-types of hashable?
(T : Collection),
(t : Number),
(hash : ((T) -> Number)),
(hash : ((t) -> Number)),
(hashable : [(x : *), (? (hash x) x)])



How to talk about vectors?
[(m : Collection), (t : Type), (? ((:(m . (* : Number))) = t) m)]



how to talk about memory layout.
two things next to each other.
multiple of the same thing next to each other.
(Unit Unit)
(Unit 1000)
What if the model is a collection and then you instantiate data using the collection



how do I represent unbounded types?
should there even be a difference?
yes.
a quantified type is an unbounded type.
each type constructed is unique anyways.
so a continuous type is represented as a number of conditions which must be true.

(is-t <- (n -> (? (p /\ q /\ r) true false)))

so then do I need types at all?
is the type assertion even a part of the language or is it a macro?
It's a macro.
So is the debugger.
in fact, everything's a macro except for the basic language.
what about quantification?
nope.
what about simple type-checking for stuff like functions?
how do i do polymophism if the function doesn't work?
case matching.
you call the function on a case.
