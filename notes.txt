There is no quantification through types since types are infinite.
Instead you have refinements via 
(T | (x -> f x))


I do not have coroutines or anything like that. 
I have CPS and macros that perform CPS transforms.


Pointers are done with only one operator.
{'@ Any} results in a reference
{'@ Reference} results in a datum
{'@ Reference} : Reference) results in a reference

Top type is "Any".
Bottom type is "None".


What are my basic types?
- Number
  - Integer
  - Natural
  - Floating (for decimal)
- Function
- Collection
  - Type
  - Expression
  - String
- Program
  - Expression
  - Symbol
- Character
- Data
  - Value
  - Reference
  - Byte


There's two kinds of types, discrete and continuous.
A discrete type is anything that has a countable number of inhabitants.
(discrete = [a b c])
A continuous type may have any number of inhabitants.
(continuous = (* | (x -> x)))

typeclass is talking about what stuff can be applied.
so if a slut is fuckable, then 
(slut = (* | (s -> (fuckable s) : *))
that's how you do a typeclass.



btw the bar represents a refinement.
(* | (x -> x))


do I handle recursive bindings?
Yes because even with recursive bindings, there's still a finite amount of constructors.
for example (a = {b}, b = {a}) where a and b are resolved before their definitions are resolved.
There's some kind of typing algorithm there.



Rule 1: New objects can only be added to the active function.
Rule 2: Objects cannot change size.
Rule 3: Objects are not discarded until their function scope exits.



I can also import the M-Notation image and the N-Impl image and they combine to form macros with M-style syntax and N-style rewrites.
How does that even work though? 
It doesn't. 
I'm expressing something else.



The "unit" is an image. It has a uniform interface whether it's compiled or not.
You combine images and use them using linker commands.
You can get symbols, import objects, and other stuff.




What are my typing rules for a Collection?
Constructor...			{ ... }
	A collection has a zero or more elements.
	A collection with zero elements has a cardinality of zero.
	All collections with cardinalities of zero are equal.
	Each element has an index corresponding to the cardinality of the collection without the element plus one.
	The cardinality of a collection is equal to the index of the last element.
	The type of a collection is equal to the collection of types such that the element at the same index is a member of that type.

Union...			{} + {}
	Union constructs a new collection by adding the elements of the right to the left.
	The indicies of the elements being added must be at least one greater than the cardinality of the left Collection.
	The cardinality of the resulting collection is equivalent to the sum of the cardinalities of the left and right collections.
	The resulting collection must exhibit all the properties of a collection having resulted from a collection constructor.

Difference...			{} - {}
	Difference constructs a collection by removing elements from the left collection which are also elements of the right collection.
	The indicies of elements in the resulting collection must be sequential by one, and no greater than the cardinality.
	Given any pair of elements in the left collection, if both elements are in the resulting collection, the element with the greater index in the left collection must have a greater index in the resulting collection.
	The cardinality of the resulting collection must be equivalent to the cardinality of the right collection subtracted from the left.

Membership...			{} / Any
	Membership will yield an element of the left collection which is equivalent to the value on the right.
	If the value on the right is a type, then Membership will yield a collection of all elements which are also elements of that type.
	If the collection on the left has no elements which are equal or members of the value on the right, then Nil is returned.

Subscript...			{} _ Natural
	Subscript will yield an element with an index equivalent to the natural number given on the right.
	If the number given on the right is greater than the cardinality of the collection, Nil is returned.
	If the number given on the right is zero, the outer collection is given, or else the left collection is given.

Product...			{} * [Natural Collection]
	Product will yield a collection with the elements of the collection on the left repeating as many times as the value on the right.
	The number of repetitions is taken either as the natural number or the cardinality of the collection on the right.
	The resulting collection must exhibit all properties of a collection resulting from a constructor.



A context is a Collection which holds all bindings which are established in the definition of a function.
There are two types of bindings for which the context may be queried, symbolic bindings and expression bindings.
Symbolic bindings are defined as a function (Symbolic-Bind : ((Symbol) -> *))
Expression bindings are defined as a function (Expression-Bind : ((Quote) -> *))
Evaluation of an expression begins by querying the context with an expression.
Within the definition of an expression binding, it may query symbols.
