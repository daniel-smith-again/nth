╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║                         The nᵗʰ Programming Language                         ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

                            Copyright © Daniel Smith                            

 ┌────────────────────────────────────────────────────────────────────────────┐
 │                                 Preamble                                   │
 ├────────────────────────────────────────────────────────────────────────────┘
 │
 ├ 1 This document forms a comprehensive specification of the properties of
 │   the programming language, nᵗʰ.
 │
 ├ 2 The purpose of this document is to encourage the portability of nᵗʰ 
 │   programs across a variety of computing systems and implementations.
 │
 │┌──────────────────────────────────────────────────────────────────────────┐
 ├│                                 License                                  │
 │├──────────────────────────────────────────────────────────────────────────┘
 ││
 │├ 1 The author(s) grants the holder of this work full right of access, 
 ││   without limitation, irrevocably, in perpetuity, for any purpose,
 ││   by any means.
 ││
 │├ 2 Authorship of this work is reserved only for contributions to this
 ││   work which are made under the terms given in this license.
 ││
 │├ 3 Contribution to this work under terms other than those given in this
 ││   section constitutes authorship of a distinct and separate work, for
 ││   which the status of authorship of this particular work is not granted.
 ││
 │├ 4 In plain terms, if you, the holder of this work, create any 
 ││   derivation, modification, or copy of this work, in whole or in part,
 ││   you cannot claim that it is a form of, version of, variation of, 
 ││   or in any way associated with the work titled 
 ││   "The nᵗʰ Programming Language" without first providing it under the 
 ││   terms set out in this license.
 ││
 │└ 5 The purpose of these terms is to provide you, the licensee, the most 
 │    permissive rights and allowances, while preventing any individual or
 │    entity from claiming authorship with less permissive rights and thus
 │    reducing the availability of this work.
 │
 │┌──────────────────────────────────────────────────────────────────────────┐
 ├│                               Conformance                                │
 │├──────────────────────────────────────────────────────────────────────────┘
 ││
 │├ 1 This document represents a standard of conformance. As such, the 
 ││   descriptions therein represent requirements for an implementation.
 ││
 │├ 2 An implementation of nᵗʰ is said to conform to this standard if it 
 ││   comprehensively demonstrates all the properties described in this 
 ││   document.
 ││
 │├ 3 In cases where the practical limitations of an otherwise conforming
 ││   implementation prevent full conformance, the implementation must 
 ││   provide documentation about which clauses or sections it does not 
 ││   conform to
 ││
 │└ 4 Some clauses may be "implementation dependent" or
 │    "implementation defined" where the manner in which an implementation
 │    meets a requirement is outside the scope of conformance.
 │
 │┌──────────────────────────────────────────────────────────────────────────┐
 ├│                                  Scope                                   │
 │├──────────────────────────────────────────────────────────────────────────┘
 ││
 │├ 1 This document specifies...
 │                                     ∙ The form of an nᵗʰ program.
 │                                     ∙ The stored format of an nᵗʰ program.
 │                                     ∙ The effects of interpreting an nᵗʰ
 │                                       program.
 │                                     ∙ The process by which an nᵗʰ program is
 │                                       judged to be correct.
 │                                     ∙ The requirements of a conforming 
 │                                       implementation.
 │
 │
 │
 │
 │
 └

 ┌─────┬──────────────────────────────────────────────────────────────────────┐
 │2    │                                                            Rationale │
 └─────┴──────────────────────────────────────────────────────────────────────┘

 ┌─────┬──────────────────────────────────────────────────────────────────────┐
 │3    │                                                                Terms │
 └─────┴──────────────────────────────────────────────────────────────────────┘

 ┌─────┬──────────────────────────────────────────────────────────────────────┐
 │4    │                                                             Overview │
 └─────┴──────────────────────────────────────────────────────────────────────┘

 nᵗʰ is a programming language. you use it to write programs

 ┌─────┬──────────────────────────────────────────────────────────────────────┐
 │5    │                                                               Syntax │
 └─────┴──────────────────────────────────────────────────────────────────────┘
 see figure 1.
 the characters sequences from begin may be used interchangeably.
 the cannonical form of a source text is one which only uses () to delimit 
 expressions


 ┌─────┬──────────────────────────────────────────────────────────────────────┐
 │6    │                                                           Evaluation │
 └─────┴──────────────────────────────────────────────────────────────────────┘

  evaluation is function application with binding resolution.
  Before evaluation macros must be computed.

 ┌─────┬──────────────────────────────────────────────────────────────────────┐
 │7    │                                                                 Data │
 └─────┴──────────────────────────────────────────────────────────────────────┘

 algebraic data types.
 arrays.
 items.
 lists.
 segments and views
 bits
 ┌─────┬──────────────────────────────────────────────────────────────────────┐
 │8    │                                                             Numerics │
 └─────┴──────────────────────────────────────────────────────────────────────┘
 
 ┌─────┬──────────────────────────────────────────────────────────────────────┐
 │9    │                                                            Functions │
 └─────┴──────────────────────────────────────────────────────────────────────┘

 ┌─────┬──────────────────────────────────────────────────────────────────────┐
 │10   │                                                                Types │
 └─────┴──────────────────────────────────────────────────────────────────────┘

 ┌─────┬──────────────────────────────────────────────────────────────────────┐
 │11   │                                                              Modules │
 └─────┴──────────────────────────────────────────────────────────────────────┘

 ┌─────┬──────────────────────────────────────────────────────────────────────┐
 │12   │                                                               Images │
 └─────┴──────────────────────────────────────────────────────────────────────┘

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                                   Figures                                    ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

┏━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ 1. nᵗʰ Grammar │                                                             ┃
┠────────────────┘                                                             ┃
┃                                                                              ┃
┃              Program    → Blank | Symbol | String | Expression               ┃
┃              Blank      →  ̲ ⃗ | ^̲J̲  ̲ ⃗ | ^̲I̲ ^̲J̲                                 ┃
┃              Symbol     → □ ⃗                                                 ┃
┃              String     → "̲ Character "̲                                      ┃
┃              Character  → □ ⃗ | \̲ \̲ | \̲ "̲ | \̲ Expression                      ┃
┃              Expression → Begin List ⃗ End | Begin Blank End | Begin End      ┃
┃              Begin      → (̲ | ^̲J̲ ^̲I̲ | ^̲J̲ ^̲I̲ ⃗                                 ┃
┃              End        → )̲ | ^̲J̲ | ^̲J̲ ^̲I̲ ⃗                                    ┃
┃              List       → Item | Item Delimiter List                         ┃
┃              Item       → Symbol | Expression | Symbol Delimiter Item        ┃
┃              Delimiter  → Blank | Expression                                 ┃
┃                                                                              ┃
┠──────────────────────────────────────────────────────────────────────────────┨
┃                                                                              ┃
┃ This grammar denotes how a sequence of characters representing an nᵗʰ        ┃
┃ program may be validated. The grammar is comprised of named rules which      ┃
┃ dictate the order in which characters must appear in order to form a         ┃
┃ valid program.                                                               ┃
┃                                                                              ┃
┃ Each rule is formed by a name, followed by an arrow, followed by a list of   ┃
┃ character sequences separated by pipes (|).                                  ┃
┃                                                                              ┃
┃ A character sequence represents a permitted ordering of individual           ┃
┃ characters and other sequences. It is denoted by listing names of other      ┃
┃ rules, and single characters in the order in which they should appear,       ┃
┃ from left to right.                                                          ┃
┃                                                                              ┃
┃ Character values are denoted by any character with an underline. Character   ┃
┃ values which are not printable (control characters) are represented using    ┃
┃ their corresponding Caret Notations.                                         ┃
┃                                                                              ┃
┃ Some items in a character sequence may repeat once or more. This is denoted  ┃
┃ by a character value or rule being postfixed with an arrow ( ⃗).              ┃
┃                                                                              ┃
┃ A symbol can be comprised of any Unicode character which is not listed in a  ┃
┃ sequence rule, and which is not a control character. For this reason, the    ┃
┃ rule for "Symbol" uses the box as a placeholder corresponding to any valid   ┃
┃ Unicode character.                                                           ┃
┃                                                                              ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 
 DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT  
▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓

encoding is unicode, utf-8.
you can turn numbers into utf-8 encoded code points.
strings are utf-8 encoded too.

left and right parentheses delimit a single expression.
white space separates symbols within an expression.
device control characters one through four may prefix a symbol and should 
influence the printed representation of a symbol.
shift out and shift in delimit a non-linear expression.
vertical tab and form feed 

( )
 
⎛ ⎞
⎜ ⎟
⎝ ⎠

⎛       ⎞
⎜ over  ⎟
⎜       ⎟
⎜ under ⎟
⎝       ⎠

⎛           ⎞
⎜ overline  ⎟
⎜⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎟
⎜ underline ⎟
⎝           ⎠

significant indentation:
newline followed by a space is normal formatting.
newline followed by a tab is (
newline followed by less tabs is )
newline followed by the same number of tabs is )(
A horizontal tab followed by a newline is a vertical indentation.

the first symbol is a function, the rest are arguments to the function.

definitions:

'define ''symbol '''program
'define ''symbol '''(items Function)
'define ''program '''program
'define ' ''program ''function

What macros do I have?

define
let
?
reduce
with 
compute 
from
numerical comparison
entity comparison
function

What functions do I have?

bounds
symbol
#
##
parameters
result

what abstractions do I have?
system abstractions are formatted buffers.
You have a local region controlled by the runtime. 
It's tied to an external resource.
There's an API to digest the buffer's data.
There's another API to synchronize the buffer with the resource.

anything that runs of the system API.

System Description
- Processor Register Files
  ISA Listing
  Peripherals
  Ports
define
function
type
symbol
list
items
array
format
read
print
eval
let
apply
do
?

defining requires a non-empty string after the initial name.

what is an image?
an image stores the names of things.
what about polymorphism?
Those desugar to varargs rather than monomorphization.
actually it's fine to define a function as multiple functions and type hints will skip the initial case matching.

are formatting characters allowed in strings? like if I wanted to have a line
break, just do 
"Hello,
world" ?
yes.

strings are utf-8 encoded.
it's literally just the bytes of input.
Constructing a string can evaluate things.

what do I actually need to be compatible with a host system?
The ability to import libraries as modules.
What can I safely assume about a system?

- It has a single thread.
- It has a (flat) filesystem.
- It has RAM.

Do I really need both a type system and macros?
Type are just macros.
ADT's are already just a macro.
No, a type system to check that your program is actually working is good.
Static verification helps with large projects.


What does nth have?

Types:
You can look at a form and decide what type you will get from evaluating it.
You can constrain variables and places in execution.

Circularity:
You can capture a part of a program as a single object and then execute it.

Math:
You have integer ranges, saturating and modular. 
You have arbitrary precision algebraic numbers.

Control Flow:
You have pattern/case matching, conditional execution, and effects.

Predictable Runtime:
There's no heap, everything is on the stack.
Functions own anything that's been allocated while the function is active.
When the function returns, those things are reclaimed.
Indirection is also traced for things which have to escape the function scope.

Modules:
You can declare namespaces for things.
Parts of your program are encapsulated from other parts.
Modules form a build system where you can use external files.

Composite Data:
Algebraic Data Types, but guaranteed to occupy a contiguous region of memory.

Images:
Basically the "project file" but all code is cached in the binary file.

System stuff:
You can emit assembly and import binary objects as images.
You can also export parts of your image as libraries or executables.

Indirection:
Lists are just arrays of pointers to things.
Lists allow checked indirection.
You can use a list to refer to things on the stack.

how to make numbers be constant space?
Arbitrary precision numbers cannot be constant space.
That might be fine though.
Anything that's an items type can be destructured using comprehension syntax.


javascript array buffers and data views are an interesting system to adopt.
they pretty much solve the entire purpose of having C around.
Plus you can statically type stuff you get out of the array.
For an implementation, there's a machine type which corresponds to storage.
What are my methods for storage arrays and viewtypes though?
"Storage" or "Memory"
